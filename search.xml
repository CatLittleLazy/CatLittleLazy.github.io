<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[python预习笔记(十)]]></title>
    <url>2019/09/24/learn-py-10/</url>
    <content type="text"><![CDATA[IO(Input/Output)编程 文件读写、StringIO和BytesIO、操作文件和目录、序列化 同步IO，暂停后续操作 异步IO(复杂)，后续操作继续进行 回调模式 轮询模式 文件读写 读文件，Python中的操作跟C相似，使用文件描述符打开文件对象 123456789# 第一个参数为文件路径# 第二个参数为打开方式 r代表读取# 第三个参数为读取编码# 第四干参数为忽略编码错误f = open('learn-py-9.md','r',encoding='utf-8',errors='ignore')# 打印出文件内容，read方法会一次性将文件全部内容读取至内存中，并返回一个str对象print(f.read())# 使用完毕后需要即使关闭文件f.close() 由于文件操作很容出现IOError，所以一半都会使用try…finally实现 123456try: f = open('learn-py-9.md','r',encoding='utf-8') print(f.read())finally: if f: f.close() python提供了with语句来自动关闭文件描述符，with就是try…finally的简易写法 12with open('learn-py-9.md','r',encoding='utf-8') as f: print(f.read()) 由于f.read()方法是一次性读取全部内容，所以尽量使用read(size)读取文件内容，同时还提供了readline()每次读取一行，readlines()一次读取所有行返回list 123with open('learn-py-9.md','r',encoding='utf-8') as f: for line in f.readlines(): print(line.strip()) 在Python种将open()函数返回的有个read()方法统称为file-like Object，除文件外，还有内存的字节流、网络流、自定义流等 打开方式选择’rb’时会使用二进制方式打开，可以用来打开图片、视频等 123with open('logging.png','rb') as f: for line in f.readlines(): print(line.strip()) 写文件 写文件与读文件都需要先创建一个文件描述符，出入的模式为’w’，’a’,或’wb’，表示写文本、追加内容或二进制文件12with open('learn-py-9.md','wb') as f: f.write('hello world!') StringIO与BytesIO(用于在内存中读取) StringIO为在内存中读写str 12345678910111213141516from io import StringIO# 创建StringIO对象f = StringIO()# 写入内容f.write('hello')# 获取写入内容print(f.getvalue()) # hello# 创建读取的StringIO对象f = StringIO('Hello\nHi\nGoodbye!')# 输出内容while True: s = f.readline() if s=='': berak print(s.strip()) BytesIO为在内存中操作二进制数据 123456789101112from io import BytesIO# 创建BytesIO对象f = BytesIO()# 写入内容f.write('中文'.encode('utf-8'))# 获取写入内容print(f.getvalue()) # b'\xe4\xb8\xad\xe6\x96\x87# 创建读取的BytesIO对象f = BytesIO(b'\xe4\xb8\xad\xe6\x96\x87')# 输出内容print(f.read()) 操作文件和目录 Python内置了一些命令来实现对文件及目录的操作 12345678910111213141516171819202122232425262728293031323334353637383940414243# 导入库文件import os# 打印出系统名称：nt为windows，posix为Linux或mac系统print(os.name)# 获取系统详细信息，windows环境下该方法会报错，os的部分函数与操作系统相关print(os.uname())# 获取系统的所有环境变量print(os.environ)# 获取某个环境变量的值print(os.environ.get('path'))# 打印当前目录print(os.path.abspath('.'))# 拼接新文件夹目录，使用join可以确保分隔符正确dirpath = os.path.join('.','testdir')# 在当前目录下新创建一个testdir目录os.mkdir(dirpath)# 删除目录os.rmdir(dirpath)# 拆分路径，拆分后为两部分，第一部分为前置目录，最后一部分问文件名或最后一级目录os.path.split(dirpath)# 获取文件后缀os.path.splittext('filename')# 文件重命名os.rename('oldfilename','newfilename')# 删除文件os.remove('filename')# 判断是否是文件夹os.path.isdir(file)# 复制文件需要使用shutil中的copyfile()函数# 一行代码过滤出当前木下的所有目录[x for x in os.listdir('.') if os.path.isdir(x)]f = BytesIO()# 写入内容f.write('中文'.encode('utf-8'))# 获取写入内容print(f.getvalue()) # b'\xe4\xb8\xad\xe6\x96\x87# 创建读取的BytesIO对象f = BytesIO(b'\xe4\xb8\xad\xe6\x96\x87')# 输出内容print(f.read()) 利用os库完成某一盘符下的文件类型统计(小练习) 序列化(pickling) 把变量从内存中变为可存储或传输的过程称为序列化，反之称为反序列化(unpickling) python中提供了pickle库来完成序列化操作 123456789101112131415161718# 导入序列化库import pickle# 创建一个字典数据d = dict(name='Bob',age=20,score=88)# 将该对象序列化为bytesprint(pickle.dumps(d))# 也可以使用pickle.dump()直接将对象序列化后写入一个file-like Objectf = open('dump.txt','wb')# 第一个参数为需要实例化的对象，第二个参数为文件描述符pickle.dump(d,f)f.close()# 读取序列化对象f = open('dump.txt','rb')# 从文件中读取序列化对象d = pickle.load(f)f.close()print(d) 由于不同版本可能不兼容，所以尽量保存写不重要的数据 将序列化内容存为json是比较好的方式 12345678910111213141516171819202122232425262728JSON类型 Python类型&#123;&#125; dict[] list"string" str1234.56 int或floattrue/False True/Falsenull None# 导入json库import json# 创建一个字典数据d = dict(name='Bob',age=20,score=88)# 将该对象序列化为json字符串print(json.dumps(d))# 也可以使用json.dump()直接将对象序列化后写入一个file-like Objectf = open('dump.txt','w')# 第一个参数为需要实例化的对象，第二个参数为文件描述符json.dump(d,f)f.close()# 读取序列化对象f = open('dump.txt','r')# 从文件中读取序列化对象json_str = f.read()# 重新读取出dict类型d = json.loads(json_str)f.close()print(d) 使用json序列化类时需要为类添加上将对象转换为dict的方法，同理，进行反序列化时也需要有一个能将dict转为类的方法 1234567891011121314151617def student2dict(std): return &#123; 'name': std.name, 'age': std.age, 'score': std.score &#125;def dict2student(d): return Student(d['name'], d['age'], d['score'])# 序列化时使用studnt2dict方法，json.dumps(s,default=student2dict)# 也可以实现类的__dict__方法json.dumps(s,default=lambda obj: obj.__dict__)# 反序列化时使用object_hookjson.loads(json_str, object_hook=dict2student)]]></content>
  </entry>
  <entry>
    <title><![CDATA[python预习笔记(九)]]></title>
    <url>2019/09/24/learn-py-9/</url>
    <content type="text"><![CDATA[错误、调试和测试 错误处理、调试、单元测试、文档测试 错误处理 如下代码会先在调用bar()方法调用foo()，之后解释器会发现some_funciton()方法找不到从而报错 1234567891011121314def foo(): r = some_functionn() if r == (-1): return (-1) return rdef bar(): r = foo() if r == (-1): print('Error') else: passbar() 使用try…except…finally…错误机制可以处理一些异常 123456789try: print('try...') r = 10 / 0 print('result:',r)except ZeroDivisionError as e: print('except:',e)finally: print('finally...')print('END') 可以使用多个except来捕获不同异常，同时也可以在except都加else语句 12345678910111213try: print('try...') r = 10 / 0 print('result:',r)except ValueError as e: print('ValueError:',e)except ZeroDivisionError as e: print('ZeroDivisionError:',e)else: print('no error!')finally: print('finally...')print('END') Python种的except均继承自BaseException，所以存在父类异常捕获到后子类异常将不在捕获的现象 不需要再每个可能出错的地方都去捕获，只需要在合适的层次写一次就好 错误没有被捕获的话将会一直向上抛直到被Python解释器捕获，打印出错误信息后程序退出 使用logging模块可以记录错误信息，且程序可以继续执行，同时使用logging还可以将错误记录到日志文件中 123456789101112import loggingdef foo(s): return 10/int(s)def bar(s): return foo(s) * 2try: bar('0')except Exception as e: logging.exception(e)# 可以执行到这里print('END') 可以定义自己的异常类 12345678910class FooError(ValueError): passdef foo(s): n = int(s) if n == 0: raise FooError('invalid value: %s' % s) return 10 / n# 运行后可以追踪到自己定义的错误foo('0') 错误处理方式，捕获异常的目的只是记录一下，便于后续追踪，raise不进行异常转换时后面不跟任何参数可以将当前异常原样抛出 123456789101112131415def foo(s): n = int(s) if n==0: raise ValueError('invalid value: %s' % s) return 10 / ndef bar(): try: foo('0') except ValueError as e: print('ValueError!') # 通过raise将该异常继续抛出 raisebar() 调试 简单粗暴的使用print()来打印变量值以便直到出错的地方，之后还得删除 断言assert，可以将使用print()辅助的地方使用assert()完成，断言可以在启动时关闭，python -O xxx.py，此时断言会被解释为pass 1234567def foo(s): n = int(s) # 若断言失败则会抛出AssertionError assert n != 0, 'n is zero!' return 10 / nfoo('0') logging，不会抛出错误且可以输出到日志文件 12345678import logging # logging日志级别：debug,info,warning,errorlogging.getLogger().setLevel(logging.INFO)s = '0'n = int(s)logging.info('n = %d' % n)print(10 / n)print('END') pdb调试器，终端输入python -m pdb xxx.py后，n为单步调试，p xx即可打印出xx 变量当前值,q为退出 pdb.set_trace()在可能出错的地方设置断点，此时运行程序后会在断点处停止进入pdb模式,c名利继续执行123456import pdbs = '0'n = int(s)pdb.set_trace()print(10 / n)print('END') 单元测试 单元测试的意义在后期若对该部分做了修改，那么跑一遍单元测试用例后，若通过则说明此次修改不会对原有单元产生影响，不通过则说明于原有行为不一致，需要修改代码或修改测试 以编写一个可以通过属性来访问的Dict类为例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# 先编写一个继承自dict的Dict类class Dict(dict): # 构造方法同时调用父类dict的构造方法 def __init__(self,**kw): super().__init__(**kw) # 该方法支持直接获取key的值，也就是将d.a等价于d[a] def __getattr__(self,key): try: return self[key] # 若没有该key则抛出异常 except KeyError: raise AttributeError(r"'Dict' object has no attribute '%s'" % key) # 该方法支持直接设置key对应的value def __setattr__(self,key,value): self[key] = value# 导入单元测试类import unittest# 编写测试类，继承自unittest.TestCase类，只会执行test开头的方法为测试方法class TestDict(unittest.TestCase): def test_init(self): d = Dict(a=1,b='test') self.assertEqual(d.a,1) self.assertEqual(d.b,'test') self.assertTrue(isinstance(d,dict)) def test_key(self): d = Dict() d['key'] = 'value' self.assertEqual(d.key,'value') def test_attr(self): d = Dict() d.key = 'value' self.assertTrue('key' in d) self.assertEqual(d['key'],'value') def test_keyerror(self): d = Dict() with self.assertRaises(KeyError): value = d['empty'] def test_attrerror(self): d = Dict() with self.assertRaises(AttributeError): value = d.empty 对每一类测试都编写一个test_xx()方法，然后使用unittest.TestCase提供的内置方法来判断是否是期望的方法 assertEqual(abs(-1),1)，后面的值为期望的值 assertRaises(Error),Error为期待抛出的异常 python xxx_test.py 运行单元测试， python -m unittest xxxxx 推荐的运行单元测试方法，可以一次性运行很多单元测试 setUp与tearDown是单元测试中的两个特殊方法，会在每个测试方法的开始和结束调用 单元测试代码要尽量简单，否则可能测试代码本身就有bug 文档测试(类似javadoc那种，但是其中的大妈可以使用工具运行) 当模块正常运行时不会执行doctest，只有个在命令行直接运行时才执行doctest 示例如下12345678910111213141516171819202122232425262728293031323334class Dict(dict): ''' Simple dict but also support access as x.y style. &gt;&gt;&gt; d1 = Dict() &gt;&gt;&gt; d1['x'] = 100 &gt;&gt;&gt; d1.x 100 &gt;&gt;&gt; d1.y = 200 &gt;&gt;&gt; d1['y'] 200 &gt;&gt;&gt; d2 = Dict(a=1, b=2, c='3') &gt;&gt;&gt; d2.c '3' &gt;&gt;&gt; d2['empty'] Traceback (most recent call last): ... KeyError: 'empty' &gt;&gt;&gt; d2.empty Traceback (most recent call last): ... AttributeError: 'Dict' object has no attribute 'empty' ''' def __init__(self, **kw): super(Dict, self).__init__(**kw) def __getattr__(self, key): try: return self[key] except KeyError: raise AttributeError(r"'Dict' object has no attribute '%s'" % key) def __setattr__(self, key, value): self[key] = value]]></content>
  </entry>
  <entry>
    <title><![CDATA[python预习笔记(八)]]></title>
    <url>2019/09/23/learn-py-8/</url>
    <content type="text"><![CDATA[面向对象高级编程 多重继承、定制类、元类 使用slots 通过MethodType给类动态添加方法 123456789101112131415161718192021222324# 声明一个什么都不做的Student类class Student(object): pass# 声明一个设置分数的方法，添加后同时为类添加了score属性def set_score(self,score): self.score = score# 导入所需的库from types import MethodType# 动态的为Student添加set_score方法Student.set_score = set_scores = Student()s.set_score(100)print(s.score) # 100# 也可以动态的为实例添加方法def set_age(self,age): self.age = age# 该方法只对实例s生效s.set_age = MethodType(set_age,s) 声明类的时候添加特殊的slots变量可以限制class实例的动态添加 123class Student(object): # 声明该类只能动态添加name、age属性或方法 __slots__ = ('name','age') 父类的slots对子类不起作用，子类若定义了slots(即便子类的限制为空)，则子类的限制为父类与子类之和 使用@property(很Nice) 未使用@property的私有成员属性写法 1234567891011class Student(object): def get_score(self): return self._score def set_score(self, value): if not isinstance(value, int): raise ValueError('score must be an integer!') if value &lt; 0 or value &gt; 100: raise ValueError('score must between 0 ~ 100!') self._score = value @property装饰器负责把一个方法变成属性调用 123456789101112131415class Student(object): # 通过@property将score变为属性 @property def score(self): return self._score # 通过@score.setter将setter方法变为属性赋值 @score.setter def score(self, value): if not isinstance(value, int): raise ValueError('score must be an integer!') if value &lt; 0 or value &gt; 100: raise ValueError('score must between 0 ~ 100!') self._score = value 通过@property定义只读属性 1234567891011121314class Student(object): @property def birth(self): return self._birth @birth.setter def birth(self, value): self._birth = value # age属性未添加set方法，所以age属性为只读属性 @property def age(self): return 2015 - self._birth 多重继承(多考虑组合而不是复杂的继承链) 主线一般都是单一继承下来，比如Cat除了继承Animal 如果要加入额外的功能，为Cat再加入Runnable。这样的设计成为MixIn12class Dog(Animal, RunnableMixIn, CarnivorousMixIn): pass 定制类(类中的特殊变量slots或函数名len()) str()，类比java中toString() 12345678910class MyClass(object): def __init__(self,name): self.name = name # 添加__str__方法后打印方法调用该方法，而不再是打印出内存地址 def __str__(self): return 'MyClass object (name: %s)' % self.nameprint(MyClass('Mi'))# 输出结果为:MyClass object (name: Mi) repr()方法用于直接打印实例时使用 12345678910111213class MyClass(object): def __init__(self,name): self.name = name # 添加__str__方法后打印方法调用该方法，而不再是打印出内存地址 def __str__(self): return 'MyClass object (name: %s)' % self.name # 偷懒的使__repr__方法指向__str__方法，否则直接打印出内存地址 __repr__ = __str__s = MyClass('Mi')print(s)# 输出结果为:MyClass object (name: Mi) iter()方法为类添加迭代功能，可以理解为实现了Iter接口使对象可遍历，同时还需要实现next() 1234567891011121314151617181920class Fib(object): # 定义了类的成员变量a,b且初始化为0,1 def __init__(self): self.a,self.b = 0,1 # 实现__iter__方法返回本身 def __iter__(self): return self # 实现__next__方法返回下一个值 def __next__(self): # 计算出下一个值 self.a,self.b = self.b,self.a + self.b # 退出循环的条件 if self.a&gt;1000: raise StopIteration() return self.a# 遍历Fib()for n in Fib(): print(n) getitem()方法实现根据下标取出元素 1234567891011121314151617181920212223242526272829303132class Fib(object): def __getitem__(self,n): a,b=1,1 for x in range(n): a,b = b , a+b return aprint(Fib()[5]) # 输出8，为Fib()添加下标访问# 此时进行切片Fib()[1:3]会报错，因为__getitem__方法中未对切片对象做处理def __getitem__(self,n): if isinstance(n,int): a,b = 1,1 for x in range(n): a,b = b,a+b return a if isinstance(n,slice): start = n.start stop = n.stop if start is None: start = 0 a,b = 1,1 L = [] for x in range(stop): if x &gt;= start: L.append(a) a,b = b,a+b return L# 但是此时还未对step进行处理 getattr方法可以用来避免获取没有属性时的报错(后面讲的有点没懂其实) 1234567891011121314151617class Student(object): def __init__(self): self.name = 'Michael' def __getattr__(self,attr): if attr == 'score': retrun 99 # 返回方法也可以 if attr == 'fn': return lambda:25 # 添加该句子后只会响应fn、score，对于age会抛出如下异常 raise AttributeError('has no attribute %s' % attr)s = Student()print(s.name) # 输出Michaelprint(s.score) # 输出99(这里的99就是调用了getattr方法返回的值)print(s.age) # 输出None(默认输出为None，若没有getattr方法则报错) call方法实现类实例的自身调用 12345678# 为类添加该方法后类的实例可以完成自身调用 def __call__(self): passs = Studnet("Michael")print(s()) # __call__方法默认返回None# 使用callable(obj)可以判断对象是否可调用 使用枚举类 创建枚举类及枚举类的遍历 12345from enum import EnumMonth = Enum('Month',('Jan','Feb','Mar'))for name,member in Month.__members__.items(): # value属性时自动赋值给成员的int常量，默认从1开始 print(name,'=&gt;',member,',',member.value) 如果需要更精确的控制可以派生出自定义枚举类 12345678910111213141516from enum import Enum,unique# 添加unique装饰器确定Weekday中没有重复元素，如果取消unique，添加Sunn=0后打印Weekday(0)取出的元素为Sunn@uniqueclass Weekday(Enum): Sun = 0 Mon = 1 Tue = 2 Wed = 3 Thu = 4 Fri = 5 Sat = 6day = Weekday.Monprint(day) # 打印Week.Monprint(day.value) # 打印 1print(Weekday(5)) # 打印Week.Fri 使用枚举元素 123456789101112from enum import Enum,unique@uniqueclass Gender(Enum): Male = 0 Female = 1class Student(object): def __init__(self,gender): if gender in Gender: self.gender = gender else: raise ValueError("Invalid gender") 使用元类 定义一个hello.py的class 123class Hello(object): def hello(self,name='word'): print('Hello, %s.' % name) 使用from hello import Hello导入模块时，Python解释器会一次执行该模块的所有语句，执行结果就是动态创建出一个Hello的class对象 123456# 实际就是执行了模块的所有语句，且动态创建出一个Hello的class对象from hello improt Helloh = Hello()h.hello() # 打印 Hello, word.print(type(Hello)) # &lt;class 'type'&gt;print(type(h)) # &lt;class 'hello.Hello'&gt; type()函数可以查看类型，class的类型是type，class的定义是动态创建的，我们可以使用type()方法动态创建出Hellon类 1234567# 首先定义出方法def fn(self,name = 'world'): print('Hello, %s.' % name)# 动态创建出Hello类，第一个参数为类名，第二个参数为父类，注意单元素tuple写法，第三个参数为函数名Hello = type('Hello',(object,),dict(hello=fn))h = Hello()h.hello() 动态创建于直接手写class是没有去别的，Python解释器在遇到class定义时，仅仅是扫描一下class定义的语法，然后调用type()函数创建class metaclass(元类)可以用于控制类的创建行为，先创建metaclass，就可以创建类，然后创建实例，可以理解为类是metaclass的实例 1234567891011121314151617# 使用metaclass为List添加add方法# 首先定义一个metaclass，其实也就是起到了一个重置创建了类的构造函数(自己的肤浅理解)class ListMetaclass(type): # cls 当前准备创建的类的对象 # name 类的名字 # bases 当前类的父类 # attrs 类的方法集合 def __new__(cls,name,bases,attrs): attrs['add'] = lambda self,value: self.append(value) return type.__new__(cls,name,bases,attrs)# Python解释器读到metaclass=ListMetaclass时会从该类中的__new__()方法创建类class MyList(list,metaclass=ListMetaclass): passL = MyList()L.add('1') # 由于使用了metaclass为类添加了add方法，所以可以调用add方法直接添加元素 ORM(Object Relational Mapping)对象—关系映射，在编写该框架时，由于所有的类都只能动态定义，因为只有使用者才能根据表的结构定义出对应的类，所以需要大量使用metaclass]]></content>
  </entry>
  <entry>
    <title><![CDATA[python预习笔记(七)]]></title>
    <url>2019/09/19/learn-py-7/</url>
    <content type="text"><![CDATA[面向对象编程(Object Oriented Programming) 以展示学生成绩为例，面向过程写法为12std1 = &#123;'name':'Michael','score':97&#125;std2 = &#123;'name':'Bob','score':81&#125; 面向对象写法为123456789101112class Student(object): def __init__(self,name,score): self.name = name; self.score = score def print_score(self): print('%s: %s' % (self.name,self.score))bart = Student('Bart',59)lisa = Student('Lisa',87)bart.print_score()lisa.print_score() 类(Class)与实例(Instance) 创建类 1234567891011121314#关键字 类名 父类(没有父类可以写object)class Student (object): pass# 声明一个Student的实例对象bartbart = Student()# 类中的__init__方法为构造函数，且第一个参数永远是self，方法内部可以将各个属性绑定至self，也就是创建的实例本身def __init__(self,name,score): self.name = name; self.score = score# 定义类中的函数与普通函数不同之处在于第一个参数永远是实力变量self，且调用时不需要传入该参数def print_score(self): print('%s: %s' % (self.name,self.score)) 数据封装指讲类的成员变量封装入类方法中实现其逻辑而不对外暴露，如print_scroe()方法只是直接打印出了成员变量name,scroe，同时还可以利用封装添加新的方法，如get_grade 1234567def get_grade(self): if self.score &gt;= 90: return 'A' elif self.score &gt;= 60: return 'B' else: return 'C' 类是创建实例的模板，实例则是一个个具体的对象 与静态语言不通，python允许对实例变量绑定任何数据 123user = Student()user.age = 8 #静态语言会直接报错print(user.age) #打印结果为8 访问限制 在Student中的成员变量未声明为私有变量，所以外部代码可以直接进行修改 12bart = Student('Bart',59)bart.score = 99 在成员变量前添加两个下划线即可声明为私有成员变量(pirvate)，此时在外部代码对私有成员变量进行修改无效 123def __init__(self,name,score): self.__name = name self.__score = score 对私有成员变量的修改可以提供set、get方法 1234def get_name(self): return self.__namedef set_name(self,name): self.__name = name 在Python中变量名类似xxx为特殊变量，可以直接方位，并非私有变量 在Python中单独_开头的是约定俗成的私有变量，也即是可以访问到，但是请视为私有的，不要随意访问 私有成员变量也是可以访问，解释器将私有变量更名为_类名__变量名 12bart = Student('Bart',98)print(bart._Student__score) #访问到98 继承与多态 定义一个类时，可以从现有的类中继承，如Student继承自object，新的类(Student)成为子类(Subclass)，被继承的类称为基类或父类、超类(Base class or Super class) 子类继承父类后会拥有父类的全部功能，如新增一个Representative课代表类，Representative类会直接拥有Student类中的功能 子类可以重写父类中已有的方法，通过重写实现多态，也就是根据调用方法的对象确定具体使用父类方法还是子类方法 12345678910111213141516171819202122232425262728293031# 课代表类继承自学生类class Representative(Student): # 课代表类的构造方法，在学生类初上添加学科字段 def __init__(self,name,score,gender,subj): # 调用父类Student学生类的构造方法 super().__init__(name,score,gender) # 对新怎字段命名 self.__subj = subj # 重写打印成绩类 def print_score(self): # 调用父类学生类打印成绩 super().print_score() # 返回课代表学科 return self.__subj # 创建数学课代表实例mathRep = Representative('rr',99,'female','math')# 调用重写的方法打印成绩print(mathRep.print_score())# 定义一个打印成绩的方法def print_user_score(student): print(student.print_score())# 开闭原则# 对象为Studentprint_user_score(lisa)# 对象为Representativeprint_user_score(mathRep) 开闭原则(对于print_user_score方法而言) 对扩展开放：允许新增Student子类Representative课代类作为参数 对修改封闭：不需要修改依赖Student类型的print_user_score方法 类可以一级一级的下继承下来，如Student继承自object，Representative继承自Student 若是Java，需要保证print_user_score()方法接收的是一个Student或其子类，对于Python而言则只需要保证出入实例具有print_score()方法即可 获取对象信息 使用type(obj)获取obj的类型 1234type(123) # &lt;class 'int'&gt;type(lisa) # # &lt;class '__main__.Student'&gt;type(mathRep) # &lt;class '__main__.Representative'&gt;type(abs) # &lt;class 'builtin_function_or_method'&gt; 使用tpye(obj)做类型判断 12345type(123) == int # Truetype(lisa) == Student # Truetype(mathRep) == Student # False，这里没有判断出继承关系type(lisa) == Representative # False type(abs) == types.BuiltinFunctionType # True 使用isinstance()判断类的类型更为方便 12345isinstance(lisa,Student) # Trueisinstance(mathRep,Student) # True，判断出继承关系isinstance(lisa,Representative) # False 无法自动上转型# 判断是否属于某种类型isinstance([1,2,3],(list,tuple)) 使用dir(obj)获取实例信息(类比反射) 12# 打印出lisa实例的所有方法及变量dir(lisa) 使用getattr()、setattr()、hasattr()可以操作对象的状态123456# 打印出lisa实例的所有方法及变量hasattr(lisa,'x') # Falsehasattr(lisa,'__name') # Truegetattr(lisa,'x',10) # 有x成员变量时返回对应的值，没有事返回10fn = getattr(lisa,'get_gender') # 获取方法变量， fn() # 执行get_gender()方法 实例属性与类属性(即成员变量与类变量) 定义类属性 12345678910class Student(object): # 这里的name为类属性，可以理解为static修饰的类变量，所有实例都能访问到 name = 'Student' def __init__(self, name): # 这里的name为实例属性 self.name = namelisa = Student('lisa')print(lisa.name) # 打印出lisaprint(Student.name) # 打印出Student 类属性与实例属性相同时，实例属性优先级高，且会屏蔽掉类属性 可以使用类属性做计数器 1234567class Student(object): count = 0 def __init__(self,name,score,gender): self.__name = name; self.__score = score self.set_gender(gender) Student.count = Student.count + 1 类属性同样会被继承类拥有 参考文档廖雪峰Python3教程]]></content>
  </entry>
  <entry>
    <title><![CDATA[Ocean主题添加字数统计及阅读时长估计]]></title>
    <url>2019/09/19/OceanAddWordCount/</url>
    <content type="text"><![CDATA[添加wordcount插件 Node版本在7.6.0之前1npm install hexo-wordcount@2 --save Node版本较高1npm i --save hexo-wordcount 主题配置中开启wordcount插件 在Ocean的_config.yml文件追加12#字符统计word_count: True 在网上下载想要的图标放置于ocean/source/images/文件夹 新建一个word.ejs文件(图片使用的就是上面下载的图片)置于blog/themes/ocean/layout/_partial/post/目录下1234567891011121314151617&lt;div style=&quot;display:inline;float:left;margin-top:2vh&quot;&gt; &lt;span class=&quot;post-time&quot;&gt; &lt;span class=&quot;post-meta-item-icon&quot;&gt; &lt;image class=&quot;fa fa-keyboard-o&quot; src=&apos;/blog/public/images/word.png&apos;/&gt; &lt;span class=&quot;post-meta-item-text&quot;&gt; 字数统计: &lt;/span&gt; &lt;span class=&quot;post-count&quot; style=&apos;color:gray&apos;&gt;&lt;%= wordcount(post.content) %&gt;字&lt;/span&gt; &lt;/span&gt; &lt;/span&gt; &lt;span class=&quot;post-time&quot;&gt; &amp;nbsp; &amp;nbsp; &lt;span class=&quot;post-meta-item-icon&quot;&gt; &lt;image class=&quot;fa fa-keyboard-o&quot; src=&apos;/blog/public/images/time.png&apos;/&gt; &lt;span class=&quot;post-meta-item-text&quot;&gt; 阅读时长: &lt;/span&gt; &lt;span class=&quot;post-count&quot; style=&apos;color:gray&apos;&gt;&lt;%= min2read(post.content) %&gt;分&lt;/span&gt; &lt;/span&gt; &lt;/span&gt;&lt;/div&gt; 修改article.ejs(用于文章显示) 添加统计元素 ocean/layout/_partial/目录下123456789&lt;% if (index || is_post()) &#123; %&gt; &lt;div class=&quot;article-meta&quot;&gt;&lt;% if(theme.word_count) &#123; %&gt; &lt;%- partial(&apos;post/word&apos;) %&gt;&lt;% &#125; %&gt; &lt;%- partial(&apos;post/date&apos;, &#123;class_name: &apos;article-date&apos;, date_format: null&#125;) %&gt;&lt;%- partial(&apos;post/category&apos;) %&gt; &lt;/div&gt;&lt;% &#125; %&gt; 修改显示位置 ocean/layout/_partial/尾部123456&lt;script&gt;for(var i = 0;i &lt; document.getElementsByClassName(&quot;article-date&quot;).length;i++)&#123; document.getElementsByClassName(&quot;article-date&quot;)[i].style.float=&quot;right&quot;; document.getElementsByClassName(&quot;article-date&quot;)[i].style.marginTop=&quot;2vh&quot;;&#125;&lt;/script&gt; 修改after-footer.ejs(用于首页显示)ocean/layout/_partial/尾部123456&lt;script&gt;for(var i = 0;i &lt; document.getElementsByClassName(&quot;article-date&quot;).length;i++)&#123; document.getElementsByClassName(&quot;article-date&quot;)[i].style.float=&quot;right&quot;; document.getElementsByClassName(&quot;article-date&quot;)[i].style.marginTop=&quot;2vh&quot;;&#125;&lt;/script&gt; 最终效果如下 首页 详情页 参考文档安装wordcount主题美化]]></content>
  </entry>
  <entry>
    <title><![CDATA[python预习笔记(六)]]></title>
    <url>2019/09/18/learn-py-6/</url>
    <content type="text"><![CDATA[使用模块 将函数实现在不同的文件中，使用时导入对应的模块即可 123456789101112131415161718192021222324#!/usr/bin/env python3# -*- coding: utf-8 -*-#模块的文档注释' a test module'#模块作者__author__ = 'Wyt'#导入sys模块import sysdef test(): # sys的argv变量使用list存储了命令行的所有参数且至少有一个元素(文件名) args = sys.argv if len(args) == 1: print('Hello,world!') elif len(args) == 2: print('Hello,%s!' % args[1]) else: print('Too many arguments!')# 主要用于测试，导入hello时将失效，可以理解为单元测试部分if __name__ == '__main__': test() 作用域可以通过模块中方法名前添加_实现私有成员变量或方法，但是由于python中没有实现private所以其实还是可以访问，只是以此作为标志而已 安装第三方模块(windows下) python官网下载的zip解压版会有问题，需要重新下载Windows x86 executable installer版本 下载后重新配置环境变量，配置完成后重启生效环境变量 打开cmd进入python37/Scripts(也可以讲pip加入环境变量中) 输入pip install pillow安装第三方模块 常用第三方模块 Pillow123456789101112131415161718192021222324252627282930313233343536373839404142# 导入需要的库import randomfrom PIL import Image,ImageFilter,ImageDraw,ImageFont# 生成随机字母，65-90对应a-z的asc码def rndChar(): return chr(random.randint(65,90))# 生成随机颜色1def rndColor(): return (random.randint(64,255),random.randint(64,255),random.randint(64,255))# 生成随机颜色2def rndColor2(): return (random.randint(32,127),random.randint(32,127),random.randint(32,127))# 生成随机码def createCode(): # 宽度 width = 60 * 4 # 高度 height = 60 # 创建一个新的图片 image = Image.new('RGB',(width,height),(255,255,255)) # 创建font对象，注意这里的ttf需要自己提供 font = ImageFont.truetype('km.ttf',36) # 创建draw对象 draw = ImageDraw.Draw(image) # 填充每个像素 for x in range(width): for y in range(height): # 绘制背景 draw.point((x,y), fill = rndColor()) # 绘制四个字母 for t in range(4): # 书写字母,rndChar每次生成一个随机小写字母 draw.text((60 * t + 10, 10), rndChar(),font = font,fill= rndColor2()) # 进行模糊 image = image.filter(ImageFilter.BLUR) # 图片保存 image.save('code.jpg','jpeg') requests 123456789101112131415161718192021222324252627282930313233343536373839404142# 导入所需的库import requests# 调用get方法请求豆瓣首页r = requests.get('https://www.douban.com/')# 打印请求结果及内容# print(r.status_code,r.text)# 请求一个带参数的网页r = requests.get('https://www.douban.com/search',params=&#123;'q':'python','cat':'1001'&#125;)print(r.url) # 实际请求网址为:https://www.douban.com/search?q=python&amp;cat=1001# 对于直接返回json数据的响应，使用r.json()直接获取json对象r = requests.get('https://youmehe.wang/doubleKey.txt')print(r.json())# 可以传入Http header伪装手机客户端请求r = requests.get('https://www.douban.com/',headers=&#123;'User-Agent':'Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit'&#125;)print(r.text) # 返回标题显示为：豆瓣(手机版)# 发送post请求r = requests.post('https://accounts.douban.com/login',data=&#123;'form_email':'abc@tt.com','form_password':'123455'&#125;)print(r.text)# requests默认使用的application/x-www-form-urlencode对post数据编码，如参数为json，方法如下params = &#123;'key':'value'&#125;r = requests.post('https://accounts.douban.com/login',json=params)print(r.url)# 对于更复杂的文件参数，使用方法如下，需要注意读取文件需要使用rb，如此长度才为文件长度，修改post为put或delet可以上传或删除图片# 以下为伪代码upload_files = &#123;'file':open('file.name','rb')&#125;r = requests.post(url,files = upload_files)# 使用r.headers可以获取完整详情头# 使用r.cookies['key']即可获取cookies# 传入cookies方式如下(伪代码)cs = &#123;'token':'12345','status':'work'&#125;r = requests.get(url,cookies=cs)# 超时时间为选填参数r = requests.get(url,timeout=2.5) # 2.5秒 chardet(解决编码问题)(没觉得有什么用) 123456789# 导入包import chardetprint(chardet.detect(b'hello'))# 输出(编码格式),(检测概率),(语言)# &#123;'encoding': 'ascii', 'confidence': 1.0, 'language': ''&#125;data = '离离原上草，一岁一枯荣'.encode('gbk')print(chardet.detect(data))# 输出# &#123;'encoding': 'GB2312', 'confidence': 0.7407407407407407, 'language': 'Chinese'&#125; psutil(process and system utilities主要用于获取系统信息) 12345678910111213141516171819202122232425262728293031323334import psutil# 理论线程数print(psutil.cpu_count())# 逻辑核心数print(psutil.cpu_count(logical=False))# 统计CPU的用户/系统/空闲时间(不明觉厉)print(psutil.cpu_times())# 每秒刷新一次cpu使用率，共十次for x in range(10): print(psutil.cpu_percent(interval=0.5,percpu=True))# 查看内存使用率print(psutil.virtual_memory())# 查看交换内存信息print(psutil.swap_memory())# 获取磁盘信息print(psutil.disk_partitions())# 获取磁盘使用率print(psutil.disk_usage('L:\\'))# 获取磁盘IO信息print(psutil.disk_io_counters())# 获取网络读写字节/包的个数print(psutil.net_io_counters())# 获取网络接口信息print(psutil.net_if_addrs())# 获取网络接口状态print(psutil.net_if_stats())# 获取当前网络连接信息print(psutil.net_connections())# 获取进程信息print(psutil.pids())# 获取进程详细信息print(psutil.Process(3132))# psutil提供了test()函数用以模拟ps命令(任务管理器)print(psutil.test()) 参考文档廖雪峰python3教程]]></content>
  </entry>
  <entry>
    <title><![CDATA[python预习笔记(五)]]></title>
    <url>2019/09/18/learn-py-5/</url>
    <content type="text"><![CDATA[返回函数 将函数作为返回值结果 返回函数可以将一些计算延迟执行,例如求和运算 12345678910111213# 定义一个接收任意参数的函数def calc_sum(*args): ax = 0 # 定义一个内部函数 def sum(): nonlocal ax # 内部函数直接使用了外部函数的参数与局部变量(非列表等变量时需要使用nonlocal修饰) for x in args: if isinstance(x,int) or isinstance(x,float): ax = ax + x return ax # 将函数作为返回值返回 return sum 减相关参数和变量都保存在返回的函数中的操作称之为闭包 每次返回的都是新的函数，即便参数相同也是不同的对象 由于函数会在调用后才会具体执行，所以使用闭包时需要牢记一点：返回函数不要饮用任何循环变量，或者后续会发生变化的变量 12345678910111213141516171819# 定义一个返回函数def count(): # 定义list fs = [] # 循环1,2,3 for i in range(1,4): # 定义具体的返回函数 def f(): # 返回函数中的i为变量，由于调用后才会具体执行，导致最终都是用的是3 return i * i # 总计添加了三个函数 fs.append(f) return fs# 函数赋值，此时并未具体执行f的内部代码f1,f2,f3 = count()# 具体执行结果，均为9，而并非期待的1,4,9print(f1())print(f2())print(f3()) 如果一定要应用循环变量的话需要再创建一个函数，将该函数的参数绑定为循环变量当前的值 123456789101112131415161718192021# 定义一个返回函数def count(): # 定义具体的返回函数，这里传入一个变量作为运算函数的参数 def f(j): # 定义运算函数 def g(): return j * j return g # 定义list fs = [] # 循环1,2,3 for i in range(1,4): # 总计添加了三个函数，将循环变量作为参数传入返回函数 fs.append(f(i)) return fs# 函数赋值，此时并未具体执行f的内部代码f1,f2,f3 = count()# 具体执行结果成为期待的1,4,9print(f1())print(f2())print(f3()) global关键字修饰的变量为全局变量，可用在任何地方，nonlocal只能用在嵌套函数中，且只能用于外层函数修饰了的局部变量，否则会发生错误；global与nonlocal关键字修饰变量时不能直接赋值 关于闭包 在一个外函数中(如calc_sum())定义了一个内函数(sum())，内函数里运用了外函数的临时变量(ax,*args)，外函数的返回值是内函数的引用(return sum)，此时构成一个闭包 一般情况下，函数结束后会清理内存，闭包时，外函数结束时发现自己的临时变量会在内函数中使用到，此时会把临时变量绑定给内部函数，然后自己结束 闭包内函数想要修改外函数变量时需要使用nonlocal关键字修饰(python2中咩有)，或者修改外函数变量为列表 在使用闭包的过程中，闭包变量实际上只有一份，每次开启内函数都在使用同一份闭包变量123456789101112# 定义一个返回函数def outer(x): def inner(y): nonlocal x print(x,y) #a(1)为：10 1，a(3)为11 3 x = x + y return x return innera = outer(10)# 由于共用了同一份闭包变量，所以始终共用了闭包x，导致第一次为10，第二次使用时就成为了11print(a(1)) # 11pirnt(a(3)) # 14 关于list无需global声明的原因 对于普通变量在函数内进行修改时 123456789# 定义普通变量x = 1def fun(): # 声明函数内的x使用的是全局变量x，若没有这一句则会创建一个函数内部变量x，方法结束后即释放，不影响全局变量x global x x = 2print(x) # 1fun() # 函数内部修改了全局变量xprint(x) # 2 对于列表变量进行修改时： 12345678# 定义列表变量x = [1]def fun(): # 虽然未对x进行全局变量标识，但此时x为明确的，因为x此时并非一个具体的值 x[0] = 2print(x[0]) # 1fun() # 函数内部修改了全局变量xprint(x[0]) # 2 可以理解为第一个例子中传入的是rebinding(不可变对象)，而第二个是mutation(可变对象)，可类比传递了引用，所以是否需要声明global主要看是否会产生歧义，或者说是否是明确的 匿名函数 匿名函数写法 12345# 如下便是一个匿名函数lambda x: x * x# 实际上与下面写法相同def f(x): return x * x 匿名函数优点为无需写函数名，但是同时有也一个限制，即只能有一个表达式，该表达式即为匿名函数的返回值 匿名函数可以作为返回值，也可以作为一个变量使用 装饰器 在代码运行期间动态的增加一些功能，但是又不修改函数的定义，这种动态增加的方式称之为装饰器(‘Decorator’) Decorator本质上就是一个返回函数的高阶函数 @函数时，表示函数装饰另一个函数，实际的步骤分为如下两个步骤 1.将被修饰的函数作为参数传给@符号引用的函数 2.将函数B替换成为第一步的返回值12345678910111213def log(func): def wrapper(*args,**kw): # func.__name__可以打印出方法名称 print("call %s():" % func.__name__) return func(*args,**kw) return wrapper# 使用log函数修饰了now函数，调用时先将now函数传给log方法，@logdef now(): return '2015-03-25'now()# 可以理解为 now = log(now)，此时now方法指向了新的方法引用# 完成了未修改now方法而可以动态在log方法中扩张方法的功能 若装饰器本身需要传入参数，则写法更为复杂，如下： 123456789101112131415# 装饰器def log(text): def decorator(func): def wrapper(*args,**kw): print('%s %s ():' % (text,func.__name__)) return func(*args,**kw) return wrapper return decorator@log('execute')def now(): print('2015-03-25')print(now())# 实质调用的是 now = log('execute')(now)# 1、执行过程为先执行log('execute')，返回一个wrapper函数# 2、调用返回函数的，参数为now函数，最终返回一个wrapper函数 解决装饰器导致函数签名变化 装饰器import functoolsdef log(text): def decorator(func): @functools.wraps(func) def wrapper(*args,**kw): print(&apos;%s %s ():&apos; % (text,func.__name__)) return func(*args,**kw) return wrapper return decorator@log(‘execute’)def now(): print(‘2015-03-25’)print(now()) 12345678910111213141516171819+ 装饰器主要用来增强函数功能+ 使用装饰器完成函数执行时间计算# 装饰器import functools,timedef execTime(func): @functools.wraps(func) def wrapper(*args,**kw): t1 = time.time() func(*args,**kw) t2 = time.time() t = t2 - t1 print(&apos;%s() use time: %.0fs:&apos; % (func.__name__,t)) return func(*args,**kw) return wrapper@execTimedef fast(x, y): time.sleep(14) return x + y;print(fast(10,20)) 使用isfunction(x)可以判断x是否是一个函数，通过该方法可以写一个可以接受参数，或者不接受参数的装饰器 偏函数(Partial function) 实际作用就是将带有默认参数的函数中的默认参数固定为一个数值 1234567import functoolsint2 = functools.Partial(int,base=2)print(int2('10001')) # 16+1=17# 类似于以下写法的简化def int2(x,base=2): return int(x,base) 偏函数只是将默认参数重新设定默认值，在调用时也可以传入其他值 1print(int2(&apos;10001&apos;,base=10)) # 10001 偏函数源码源码如下: 123456789def partial(func, *args, **keywords): def newfunc(*fargs, **fkeywords): newkeywords = keywords.copy() newkeywords.update(fkeywords) return func(*args, *fargs, **newkeywords) newfunc.func = func newfunc.args = args newfunc.keywords = keywords return newfunc 参考文档廖雪峰python3教程斐波那契数列尾递归Python中的赋值、引用、拷贝、作用域]]></content>
  </entry>
  <entry>
    <title><![CDATA[Python抓取百度百家姓数据]]></title>
    <url>2019/09/12/hundredSurnName/</url>
    <content type="text"><![CDATA[获取所有姓氏 进入百家姓获取所有百家姓姓氏 观察后得出单姓与复姓的分割位置如下： 分别复制单姓与复姓姓氏构造list如下(利用sublime多行操作ctrl+shift+l很容易完成)： 获得姓氏爬取网址 使用百度搜索姓，以’王’为例，此时网址为:https://baike.baidu.com/item/王/504?fr=aladdin 直接更改网址中的’王’为’李’后网址进入error.html 重新尝试再姓氏后加上姓得到网址:https://baike.baidu.com/item/王姓 更改王姓为宋姓后页面显示宋姓信息 故:url=’https://baike.baidu.com/item/&#39; + surnName + ‘姓’ 分析网页内容 以王姓为例先抓取网页内容至本地: 12345678910# 导入需要的库(python3后统一使用使用urllib.request)import urllib.request# 请求网页数据page = urllib.request.urlopen('https://baike.baidu.com/item/' + urllib.parse.quote('王姓', safe='/', encoding=None, errors=None))# 获取数据内容data = page.read()# 写入本地文件with open('web_got.html', 'wb') as f: # 接收的数据写入文件 f.write(data) f.close() 本内文件内容如下： 使用正则获取如下部分: 123456# 导入正则库import re# 使用正则匹配数据re_content = re.findall('(?&lt;=content=").+?(?=")', data.decode('utf-8'))获取数据如下print(re_content) 最终方法代码如下1234567891011121314151617181920212223242526272829303132# 姓氏，保存文件名，搜索有误姓氏记录def getInfo(surnName,fileName,needSearchFileName): # 根据姓氏请求数据 page = urllib.request.urlopen('https://baike.baidu.com/item/' + urllib.parse.quote(surnName+'姓', safe='/', encoding=None, errors=None)) # 获取请求结果 data = page.read() # 正则匹配出所需数据 re_content = re.findall('(?&lt;=content=").+?(?=")', data.decode('utf-8')) # 无数据时记录至文件 if len(re_content) == 0: with open(needSearchFileName+'.txt', 'a',encoding='utf-8') as f: f.write('该姓氏搜索无结果:'+surnName+'\n') f.close() return 0 # 搜索出的结果进行拼接json数据后写入文件 elif re_content[2].find('。',0,len(re_content[2])-1) != -1: content = '' with open(fileName+'.txt', 'a',encoding='utf-8') as f: # 只提取前两句描述 if len(re_content[2].split('。'))&gt;2: content = re_content[2].split('。')[0] + '。' + re_content[2].split('。')[1]+'。' else: content = re_content[2] f.write(',&#123;\"surnName\"'+':\"'+surnName +'\",\"Summary\":\"'+ content + '\"&#125;') f.close() return 1 # 多义姓氏需要单独搜索 else: with open(needSearchFileName+'.txt', 'a',encoding='utf-8') as f: f.write('需要单独搜索的姓氏:'+surnName+'\n') f.close() return 0]]></content>
  </entry>
  <entry>
    <title><![CDATA[python预习笔记(四)]]></title>
    <url>2019/09/10/learn-py-4/</url>
    <content type="text"><![CDATA[高阶函数 Higher-order function，一个函数就可以接收另一个函数作为参数 以abs函数为例 map()与reduce() map() map(fx,obj)，第一个fx即为函数名，第二个obj需要是实现了Iterable的对象，调用map方法后会将传入的obj对象使用fx函数加工后返回一个Iterator对象 map(str,obj)可以将obj转换为str类型 reduce() reduce(fx,obj)，参数与map类似，第一个函数必须接收两个参数，调用reduce方法后的过程可以类比递归，不断地将fx函数的值与下一个obj元素进行运算 以求和为例1234567# 导入reducefrom functools import reduce# 定义相加def add(x,y): return x + y# 使用reduce对[1,3,5,7,9]进行求和print(reduce(add,[x for x in range(10) if x % 2!=0])) reduce与map共用完成字符串转int 123456789101112# 纯数字字符串转换为int类型def str2int(s): # 得出xy，eg:fh(1,2)，返回12 def fh(x,y): return x * 10 + y # 将0-9的字符转为对应整形 def char2num(s): return DIGETS[s] # 通过map将传入数字字符串转变为list((int)s)，如['1','3','5']转为[1,3,5]，再利用reduce求出结果135 return reduce(fh,map(char2num,s))print(str2int('123456')) filter() 该函数用于过滤数列 filter(fx,obj)，参数与map相同，不过在调用时根据返回值为True或False来决定是否保留该值 如删除list中的奇数 filter函数返回的是一个Iterator，即惰性序列，也就是迭代器 使用filter求素数(埃氏筛法)(不是很懂筛选函数部分，需要再理解) 12345678910111213141516171819202122def _odd_iter(): n = 1 while True: n = n + 2 yield ndef _not_divisible(n): return lambda x: x % n &gt; 0def primes(): yield 2 it = _odd_iter() while True: n = next(it) yield n it = filter(_not_divisible(n),it)for n in primes(): if n &lt; 14: print(n) else: break 使用filter得出回文数 123456789101112# 测试逆序切片print('12345'[-1:-3:-1])# 筛选器def is_palindrome(s): # 整除算出中位 middle = len(s) // 2 # 对中位进行切片及逆序切片判断是否相等 return s[:middle]==s[-1:-(middle+1):-1]# 使用str将数字转为字符串好方便完成切片output = filter(is_palindrome,[str(x) for x in range(1,1000)])# 由于filter返回的是迭代器使用list得出所有结果print(list(output)) sorted() sorted(obj)传入对象为list或tuple时会对其中元素进行排序，需要主要的是此时传入元素类型需要一致 sorted(obj,key=*fx)可以接收一个key函数实现自定义的排序，可以类比Java中的比较器 sorted()排序的关键在于实现一个映射函数 使用sorted()进行排序12345678910# 已有数据L = [('Bob', 75), ('Adam', 92), ('Bart', 66), ('Lisa', 88)]# 按照名字排序def by_name(n): return n[0]print('按照名字排序:',sorted(L,key=by_name))# 按照分数排序def by_score(s): return s[1]print('按照分数排序:',sorted(L,key=by_score)) 参考文档廖雪峰python3教程斐波那契数列尾递归]]></content>
  </entry>
  <entry>
    <title><![CDATA[python预习笔记(三)]]></title>
    <url>2019/09/03/learn-py-3/</url>
    <content type="text"><![CDATA[切片(取出list或tuple中的部分元素，切片并非深拷贝) 取出List[‘Michael’,’Sarah’,’Tracy’,’Bob’,’Jack’]中的前三个 List[0:3] (0:其实索引，终止索引，不包括3) 起始索引为0时可以写为 List[:3] 可以直接进行逆序取值 List[-3:-2] 参数不写时视为复制List或Tuple List[:]或List[::] 整体间隔取值 List[::2] (每隔1项取值) 对结果间隔取值 List[10:15:2] (取出其中的11、13、15项，即每隔1项取值) 字符串也可以支持切片操作 ‘loveyy’[::2]结果为lvy 利用切片完成trim(str)方法12345678def myTrim(s): n = 0; result = '' while n &lt; len(s) : if s[n] != ' ': result += s[n] n = n + 1 return result 迭代 使用fon xx in xx完成list、tuple的迭代 dict也可进行迭代 for x in dict: 默认请情况下迭代key for x in dict.values(): 方法迭代value for x,y in dict.items(): 同时迭代k-v isinstance(‘abc’,Iterabel) 可以判断该对象是否可迭代 123from collections.abc import Iterableprint(isinstance(123, Iterable)) Falseprint(isinstance('abc',Iterable)) True enumerate()方法可以将list变为索引-元素对 12for x,y in enumerate(['abcdef']): print(x,y) 也可以同时迭代两个变量 12for x,y in [(1,1),(2,4),(3,9)]: print(x,y) 使用迭代完成List中寻找最大值与最小值 123456789def finMaxAndMin(L): max = L[0] min = L[0] for x in L: if x &lt; min: min = x if x &gt; max : max = x return (max,min) 列表生成式(List Comprehensions) list(range(1,11))生成[1,2,3,4,5,6,7,8,9,10] [x &#42; x for x in range(1,11)]生成[1,4,9,16,25,36,49,64,81,100] [x &#42; x for x in range(1,11) if x % 2 ==0]可以生成[4,1,36,64,100] 双层循环生成全排列:[m+n for m in ‘AB’ for n in ‘XYZ’]生成[‘AX’,’AY’,’AZ’,’BX’,’BY’,’BZ’] 使用如下代码可以遍历文件及目录12import osprint([d for d in os.listdir('.')]) 生成器(generator) 使用生成器生成的是一个算法，或者可以说是一个映射规则的可迭代对象 生成器的优势为节省空间开支，可以只在需要时取出对应的值而不是想列表生成式一样直接生成所有的元素 写法一：g = (x&#42;x for x in range(10)) 可以使用next(g)获取下一个值，也可以使用for循环进行遍历 写法二：如果一个函数中含有yield挂念自，那么该函数将成为生成器 生成器在于调用next()的时候执行，遇到yield语句返回 yield相当于设置了一个中断，没调用一次next()就会释放一个中断 当生成器的next()方法无法拿到返回值时会抛出StopIteration异常 通过如下方法获取到斐波那契数列下标对应的值 1234567891011121314151617181920# 斐波那契生成器def fib(max): n,a,b=0,0,1 while n &lt; max: yield b a , b = b ,a + b n = n + 1 return 'done'# 根据下标获取生成器中对应的值def getFib(n): g = fib(n) for x in range(n): if x == n-1: print(next(g)) else: next(g)# 获取第1999个斐波那契数getFib(1999) a,b=b,a+b相当于tuple(b,a+b);a=t[0],b=t[1]，其实也就是a=b,b=a+b 通过生成器完成杨辉三角 1234567891011def triangles(n): A = list(range(1,2)) while n&gt;0: yield A tmp = [0] + A + [0] A = [tmp[i] + tmp[i+1] for i in range(len(tmp)-1)] n = n-1o = triangles(8)for x in o: print(x) 迭代器(Iterator) 可以被next()函数不断调用并返回下一个值的对象称为迭代器 isinstance(obj,Iterator)判断对象是否为迭代器 list、dict、str不是迭代器 通过iter(obj)可以将list、dict、str变为迭代器 Iterator对象标识一个数据流且为惰性计算，只有在需要返回下一个函数时才会计算 Python的for循环本质就是不断调用next()函数实现 实现了iter方法的对象是可迭代对象，实现了next方法的对象是迭代器。 参考文档廖雪峰python3教程斐波那契数列尾递归]]></content>
  </entry>
  <entry>
    <title><![CDATA[python预习笔记(二)]]></title>
    <url>2019/08/31/learn-py-2/</url>
    <content type="text"><![CDATA[数据类型转换 int(‘123’) 123 int(12.34) 12 float(‘12.34’) 12.34 str(1.23) ‘1.23’ str(100) ‘100’ bool(1) True bool(‘’) False 函数参数 pass可以用来做占位符 isintstance()判断是否为数字，包含浮点 python的多返回值其实是返回了tuple 函数执行完毕后没有return会自动返回None 默认参数需要放在必选参数之后 默认参数会根据字段类型自动匹配，相同类型时可以添加默认参数名完成匹配 1234567def enroll(name, gender, age=6, city='Beijing'): print('name:', name) print('gender:', gender) print('age:', age) print('city:', city)enroll('Bob','M',8)enroll('Adam,'M',city=r"Xi'an") 可变参数(传入的参数个数是可变的) def calc(&#42;number);此时python内部接收的是一个tuple 可以写为cale(&#42;list)或cale(&#42;tuple) 关键字参数(可以传入任意个含参数名的参数) def person(name,age,&#42;&#42;kw); 此时python内部接收的&#42;&#42;kw是一个dict 这里的&#42;&#42;kw会将接收到参数自动处理为dictperson(“michael”,30,city=”Xi’an”,country=”China”)可以写为person(“”,””,&#42;&#42;dict)函数内部得到的是一份dict拷贝，不会影响原数据 命名关键字参数(在关键字参数基础上，确定了传入dict的key值) def person(name,age,&#42;,city,job) 只能接收只有city、job作为key的dict，否则直接编译报错可以写为person(‘Bob’,15,city=”Xi’an”,job=’programmer’)或者person(‘Bob’,15,&#42;&#42;dict) def person(name,&#42;child,city,job) 当参数中已经有一个可变参数是，则不需要再写单独&#42;号命名关键字可以有默认值，拥有默认值的key则传入的dict中可以不包含该key 参数组合的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数、关键字参数 对于任意函数都可以使用def fx(&#42;args,&#42;&#42;kw)的形式声明 默认参数一定不要使用可变对象 递归函数 尾递归优化，降低栈帧使用，Python并未支持 阶乘问题 普通递归1234def fact(n): if n == 1: return 1 return n * fact(n-1) 尾递归优化1234567def fact(n): retrun fact_iter(n,1)def fact_iter(num,product): if num == 1: return product return fact_iter(num - 1, num * product) 斐波那契数列 普通递归12345def Fibonacci(n): if n &lt;= 2: return 1 else: return Fibonacci(n-2) + Fibonacci(n-1) 尾递归优化1234def Fibonacci(n,ret1,ret2): if n == 1 : return ret1 return Fibonacci(n - 1, ret2, ret1 + ret2); 参考文档廖雪峰python3教程斐波那契数列尾递归]]></content>
  </entry>
  <entry>
    <title><![CDATA[python预习笔记(一)]]></title>
    <url>2019/08/29/learn-py-1/</url>
    <content type="text"><![CDATA[基本类型 整形 两种除法 10/3=3.333310//3=3(地板除法) 浮点数 字符串 转义字符(r’’)(‘’’content’’’) 英文 中文 布尔值 True False and、or、not 空值None list与tuple list(元素类型可不同且可嵌套的有序集合) 定义:classmates = [‘Michael’,’Bob’,’Tracy’] 长度:len(list) 取值:list[2]、list[-1] 追加:list.append(‘Adam’) or list.insert(1,’Adam’) 删除:list.pop() or list.pop(1) 嵌套:language = [‘Java’,’Python’,[‘asp’,’php’],’.net’] tuple(有序列表，初始化后不可修改) 定义:classmates = (‘Michael’,’Bob’,’Tracy’) 空: t = () 单个元素定义: t = (1,) 可变tuple:t = (‘a’,’b’,[‘A’,’B’]) dict和set dict(字典，即map) 定义:d = {‘Michael’:95,’Bob’:75,’Tracy’:85} 取值:d[‘Michael’] 是否可取:’Thomas’ in d or d.get(‘Thomas’,-1) 删除:d.pop(key) 注意事项 1、dict内部存放顺序与key放入的顺序无关2、典型的以空间换取时间3、dict的key必须是不可变对象4、None可做键、值 set(没有重复key且不存value的无序集合) 定义:s = set([1,2,3,3,2,1])重复元素会被自动过滤 添加:s.add(4) 删除:s.remove(2) 操作:求交集(&amp;)、并集(|)、减操作不具备交换性 关于dict、set中的key类型不可变 list虽然可变且，但当使用set(list)后，set会直接存储list中值内容作为自己的元素 Two Sum 问题描述 使用list遍历导致超时 12345678910111213class Solution: def twoSum(self, nums: List[int], target: int) -&gt; List[int]: result=[0,1] t = list(enumerate(nums)) for i,x in t: for j,y in t: if i==j: continue if i!=j and x+y==target: result[0] = i result[1] = j break return result 使用dict()高效完成遍历避免超时 12345678class Solution: def twoSum(self, nums: List[int], target: int) -&gt; List[int]: table = dict() for i in range(0,len(nums)): if(target - nums[i]) in table: return [i,table[target-nums[i]]] table[nums[i]] = i return [0,1] 参考文档廖雪峰python3教程TwoSum的python3算法]]></content>
  </entry>
  <entry>
    <title><![CDATA[Apaceh安装Https证书]]></title>
    <url>2019/08/26/install-https/</url>
    <content type="text"><![CDATA[前期准备 linux服务器 申请过https证书的域名 服务器安装证书 解压证书压缩包选择Apache内文件至服务器上/etc/apache2/ 进入/etc/apace2/sites-enabled/创建文件ssl.conf编辑内容如下： 1234567891011121314151617181920212223ServerName 0.0.0.0&lt;VirtualHost 0.0.0.0:443&gt; ServerAdmin webmaster@localhost DocumentRoot /var/www/html ServerName webmaster@localhost:443 #填写证书名称 #SSL Engine Switch: #Enable/Disable SSL for this virtual host. SSLEngine on # SSLCertificateFile /etc/apache2/2_.crt #证书文件的路径 SSLCertificateKeyFile /etc/apache2/3_.key #私钥文件的路径 SSLCertificateChainFile /etc/apache2/1_root_bundle.crt &lt;/VirtualHost&gt; 重启apache2服务 systemctl restart apache2 部署失败的原因443端口未开 1、先确定服务器端的防火墙安全组规则中已打开443端口2、使用nmap localhost端口扫描确定本地端口是否打开3、使用nmap 域名或者公网ip扫描对外端口是否打开4、sudo iptables -I INPUT -p tcp –dport 443 -j ACCEPT开启端口5、保存规则 sudo iptables-save 可以访问但是需要加端口 1、确定是否未创建新文件直接在000-default.conf文件中添加了内容 重启服务器报错apache2 Invalid command ‘SSLEngine’ 1、执行sudo a2enmod ssl开启ssl支持即可 证书解压失败 1、更换下载工具重试 参考文档 腾讯云官方教程 设置iptables规则 nmap使用 Invalid command ‘SSLEngine’]]></content>
  </entry>
  <entry>
    <title><![CDATA[建站的简单记录(含修改部分)]]></title>
    <url>2019/08/24/create-blog/</url>
    <content type="text"><![CDATA[已有资源 一个完成基本web服务器搭建的Linux服务器 域名一个 Putty.exe WinScp.exe 建站部分123456789101112131415161718192021222324252627//安装nodesudo apt-get install -y nodejs//安装hexo npm install -g hexo-cli//创建博客文件夹且初始化 hexo init blog //修改_config.xml中部分【url:域名/blog】、【root:/blog/public/】部分vi _config.xml//下载Ocean主题git clone https://github.com/zhwangart/hexo-theme-ocean.git themes/ocean//安装搜索库npm install hexo-generator-searchdb --save//根目录下配置文件_config.xml添加如下部分search: path: search.xml field: post content: true //主题目录下的_config.xml添加如下部分local_search: enable: true #搜索开关 Ocean主题遇到的问题搜索无效问题12345//在themes/ocean/layout/_partial/after-footer.ejs中添加如下代码(位置靠后)&lt;% if (theme.local_search.enable)&#123; %&gt; &lt;%- js('/js/search') %&gt; &lt;script&gt;searchFunc('/blog/public/search.xml','local-search-input','local-search-result')&lt;/script&gt;&lt;% &#125; %&gt; 分享按钮取消123456//在themes/ocean/layout/_partial/after-footer.ejs中添加如下代码&lt;script&gt;for(var i = 0;i &lt; document.getElementsByClassName("article-footer").length;i++)&#123; document.getElementsByClassName("article-footer")[i].style.display="none";&#125;&lt;/script&gt; 时间显示在右侧123456//在themes/ocean/layout/_partial/after-footer.ejs及article.ejs中添加如下代码&lt;script&gt;for(var i = 0;i &lt; document.getElementsByClassName("article-meta").length;i++)&#123; document.getElementsByClassName("article-meta")[i].style.float="right";&#125;&lt;/script&gt; 更改顶部视频1234//在themes/ocean/layout/_partial/ocean.ejs中修改路径即可poster="&lt;%- theme.ocean.path %&gt;phone.png"&lt;source src="&lt;%- theme.ocean.path %&gt;phone.mp4" type="video/mp4"&gt;//将视频及封面放在themes/ocean/source/images/ocean/中即可 参考内容 Hexo中文文档 Ocean主题]]></content>
  </entry>
  <entry>
    <title><![CDATA[关于]]></title>
    <url>%2Fblog%2Fpublic%2Fabout%2Findex.html</url>
    <content type="text"><![CDATA[废都Android马扎一枚 | lovesonycd@gmail.com 书籍 在读 《百年孤独》《人间草木》 已读 《活着》(2019.09.09)《局外人》(2019.08)《浮生六记》(2019.08)《牧羊少年奇幻之旅》(2019.07) 电影 已看 《友情以上》(2019.09.21 10:30)《超脱》(2019.09.11)《罗小黑战记》(2019.09.07)《燃烧》(2019.09)《浪潮》(2019.09)《死亡诗社》(2019.08)《寄生虫》(2019.08)《哪吒之魔童降世》(2019)《看不见的客人》(2019)《扫毒2》(2019)《千与千寻》(2019)《绝杀慕尼黑》(2019)《X战警：黑凤凰》(2019)《追龙2》(2019)《飞驰人生》(2019.02.05)《疯狂外星人》(2019.02.05)《流浪地球》(2019.02.05)《新喜剧之王》(2019.02.05)《龙猫》(2018.12.14)《无敌破坏王2》(2018.11.24)《无名之辈》(2018.11.18)《邪不压正》(2018.07.12)《我不是药神》(2018.07.06)《侏罗纪公园2》(2018.06.08)《幕后玩家》(2018.04.28)《爆裂无声》(2018.04.03)《芳华》(2017.12.23)《声之形》(2017.09.08) 想看 《血战钢锯岭》]]></content>
  </entry>
  <entry>
    <title><![CDATA[gallery]]></title>
    <url>%2Fblog%2Fpublic%2Fgallery%2Findex.html</url>
    <content type="text"></content>
  </entry>
</search>
